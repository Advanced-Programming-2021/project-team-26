Index: src/main/java/view/Scan.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package view;\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Scan {\n    private static Scan scan;\n    private static final Scanner scanner = new Scanner(System.in);;\n    public static Scanner getScanner(){\n        return scanner;\n    }\n\n    private Scan() {}\n\n    public static Scan getInstance() {\n        if (scan == null)\n            scan = new Scan();\n        return scan;\n    }\n\n    public String getString() {\n        return scanner.nextLine();\n    }\n\n    public HashMap<String, String> parseInput(String[] words) {\n        HashMap<String, String> values = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(\"-\")) {\n                if (i + 1 >= words.length || words[i + 1].startsWith(\"-\")) {\n                    values.put(words[i].replaceFirst(\"^-{1,2}\", \"\"), null);\n                } else {\n                    values.put(words[i].replaceFirst(\"^-{1,2}\", \"\"), words[i + 1]);\n                    i++;\n                }\n            }\n        }\n        return values;\n    }\n\n    public String getValue(HashMap<String, String> map, String key, String keyAbbreviation) {\n        if (map.containsKey(key))\n            return map.get(key);\n        else if (map.containsKey(keyAbbreviation))\n            return map.get(keyAbbreviation);\n        else\n            return null;\n    }\n\n    public Integer getInteger() {\n        String integerString = scanner.nextLine();\n        if (integerString.equals(\"cancel\"))\n            return null;\n        return Integer.parseInt(integerString);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/view/Scan.java b/src/main/java/view/Scan.java
--- a/src/main/java/view/Scan.java	
+++ b/src/main/java/view/Scan.java	
@@ -4,14 +4,17 @@
 import java.util.Scanner;
 
 public class Scan {
+    private static final Scanner scanner = new Scanner(System.in);
     private static Scan scan;
-    private static final Scanner scanner = new Scanner(System.in);;
-    public static Scanner getScanner(){
+    ;
+
+    private Scan() {
+    }
+
+    public static Scanner getScanner() {
         return scanner;
     }
 
-    private Scan() {}
-
     public static Scan getInstance() {
         if (scan == null)
             scan = new Scan();
@@ -22,16 +25,23 @@
         return scanner.nextLine();
     }
 
-    public HashMap<String, String> parseInput(String[] words) {
+    public HashMap<String, String> parseInput(String string) {
+        String[] words = string.split("\\s+");
         HashMap<String, String> values = new HashMap<>();
         for (int i = 0; i < words.length; i++) {
             if (words[i].startsWith("-")) {
-                if (i + 1 >= words.length || words[i + 1].startsWith("-")) {
-                    values.put(words[i].replaceFirst("^-{1,2}", ""), null);
-                } else {
-                    values.put(words[i].replaceFirst("^-{1,2}", ""), words[i + 1]);
+                String key = words[i].replaceFirst("^-{1,2}", "");
+                StringBuilder value = null;
+                i++;
+                while (i < words.length && !words[i].startsWith("-")) {
+                    if (value == null)
+                        value = new StringBuilder(words[i]);
+                    else
+                        value.append(" ").append(words[i]);
                     i++;
                 }
+                i--;
+                values.put(key, value.toString());
             }
         }
         return values;
Index: src/main/java/controller/SpellTrapController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.CardNotFoundException;\nimport exceptions.InvalidInput;\nimport exceptions.InvalidSelection;\nimport exceptions.NoCardSelectedException;\nimport model.*;\nimport model.cards.Card;\nimport model.cards.SpellTrap;\nimport model.cards.spell.Spell;\nimport model.cards.trap.Trap;\nimport view.Scan;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic abstract class SpellTrapController {\n\n    protected static ArrayList<SpellTrapController> allSpellTrapControllers = new ArrayList<>();\n    protected GameController gameController;\n    protected SpellTrapPosition position;\n    protected boolean canSpellTrapsBeActive = false;\n    protected boolean isHandAccessible = false;\n    protected boolean isRivalMonsterZoneAccessible = false;\n    protected boolean isOurMonsterZoneAccessible = false;\n    protected boolean isRivalGraveyardAccessible = false;\n    protected boolean isOurGraveyardAccessible = false;\n    protected boolean isOurSpellTrapAccessible = false;\n    protected boolean isRivalSpellTrapAccessible = false;\n    protected Card selectedCard = null;\n    protected CardAddress selectedCardAddress = null;\n\n    public static SpellTrapController getSpellTrapControllerBySpellTrap(SpellTrap spellTrap) {\n        for (SpellTrapController spellTrapController : allSpellTrapControllers) {\n            if (spellTrapController.getCard().getName().equals(spellTrap.getName())) {\n                    return spellTrapController;\n            }\n        }\n        return null;\n    }\n\n    public static SpellTrapController getInstance(GameController gameController, SpellTrap spellTrap, SpellTrapPosition position) {\n        if (spellTrap instanceof Spell)\n            return SpellController.getInstance(gameController, spellTrap, position);\n        else if (spellTrap instanceof Trap)\n            return TrapController.getInstance(gameController, spellTrap, position);\n        return null;\n    }\n\n    public void setCanSpellTrapsBeActive(boolean canSpellTrapsBeActive) {\n        this.canSpellTrapsBeActive = canSpellTrapsBeActive;\n    }\n\n    public void setHandAccessible(boolean handAccessible) {\n        isHandAccessible = handAccessible;\n    }\n\n    public void setRivalMonsterZoneAccessible(boolean rivalMonsterZoneAccessible) {\n        isRivalMonsterZoneAccessible = rivalMonsterZoneAccessible;\n    }\n\n    public void setOurMonsterZoneAccessible(boolean ourMonsterZoneAccessible) {\n        isOurMonsterZoneAccessible = ourMonsterZoneAccessible;\n    }\n\n    public void setRivalGraveyardAccessible(boolean rivalGraveyardAccessible) {\n        isRivalGraveyardAccessible = rivalGraveyardAccessible;\n    }\n\n    public void setOurGraveyardAccessible(boolean ourGraveyardAccessible) {\n        isOurGraveyardAccessible = ourGraveyardAccessible;\n    }\n\n    public void setSelectedCard(Card selectedCard) {\n        this.selectedCard = selectedCard;\n    }\n\n    public void setSelectedCardAddress(CardAddress selectedCardAddress) {\n        this.selectedCardAddress = selectedCardAddress;\n    }\n\n    public SpellTrapPosition getPosition() {\n        return position;\n    }\n\n    protected void setPosition(SpellTrapPosition position) {\n        this.position = position;\n    }\n\n    public GameController getGameController() {\n        return gameController;\n    }\n\n    protected void setGameController(GameController gameController) {\n        this.gameController = gameController;\n    }\n\n    public void setOurSpellTrapAccessible(boolean ourSpellTrapAccessible) {\n        isOurSpellTrapAccessible = ourSpellTrapAccessible;\n    }\n\n    public void setRivalSpellTrapAccessible(boolean rivalSpellTrapAccessible) {\n        isRivalSpellTrapAccessible = rivalSpellTrapAccessible;\n    }\n\n    public void remove() {\n\n    }\n\n    public void activate() {\n\n    }\n\n    public abstract SpellTrap getCard();\n\n    public abstract void standBy();\n\n    public boolean conditionMet() {\n        return true;\n    }\n\n    public void select(String selectCommand) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {\n        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand.split(\"\\\\s+\"));\n        Game game = gameController.getGame();\n        String addressNumber;\n\n\n        if ((addressNumber = Scan.getInstance().getValue(input, \"monster\", \"m\")) != null) {\n            int monsterNumber = Integer.parseInt(addressNumber);\n            if (monsterNumber > Board.CARD_NUMBER_IN_ROW)\n                throw new InvalidSelection();\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\") && isRivalMonsterZoneAccessible) {\n                if (game.getOtherBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedCard = game.getOtherBoard().getMonstersZone()[monsterNumber - 1].getMonster();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Opponent, monsterNumber - 1);\n                }\n            } else if (isOurMonsterZoneAccessible) {\n                if (game.getThisBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedCard = game.getThisBoard().getMonstersZone()[monsterNumber - 1].getMonster();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Me, monsterNumber - 1);\n                }\n            } else throw new InvalidSelection();\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        }\n        if ((addressNumber = Scan.getInstance().getValue(input, \"spellTrap\", \"s\")) != null) {\n            int spellTrap = Integer.parseInt(addressNumber);\n            if (spellTrap > Board.CARD_NUMBER_IN_ROW)\n                throw new InvalidSelection();\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\") && isRivalSpellTrapAccessible) {\n                if (game.getOtherBoard().getSpellTrapZone()[spellTrap - 1] != null) {\n                    selectedCard = game.getOtherBoard().getSpellTrapZone()[spellTrap - 1].getCard();\n                    selectedCardAddress = new CardAddress(Place.SpellTrapZone, Owner.Opponent, spellTrap - 1);\n                }\n            } else if (isOurSpellTrapAccessible) {\n                if (game.getThisBoard().getSpellTrapZone()[spellTrap - 1] != null) {\n                    selectedCard = game.getThisBoard().getSpellTrapZone()[spellTrap - 1].getCard();\n                    selectedCardAddress = new CardAddress(Place.SpellTrapZone, Owner.Me, spellTrap - 1);\n                }\n            } else throw new InvalidSelection();\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"hand\", \"h\")) != null && isHandAccessible) {\n            int handNumber = Integer.parseInt(addressNumber);\n            if (handNumber > game.getThisBoard().getHand().size())\n                throw new InvalidSelection();\n\n            selectedCard = game.getThisBoard().getHand().get(handNumber - 1);\n            selectedCardAddress = new CardAddress(Place.Hand, Owner.Me, handNumber - 1);\n\n            if (this.selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"graveyard\", \"g\")) != null) {\n            int graveyardNumber = Integer.parseInt(addressNumber);\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\") && isRivalGraveyardAccessible) {\n                if (graveyardNumber > game.getOtherBoard().getGraveyard().size())\n                    throw new InvalidSelection();\n                else {\n                    this.selectedCard = game.getOtherBoard().getGraveyard().get(graveyardNumber - 1);\n                    selectedCardAddress = new CardAddress(Place.Graveyard, Owner.Opponent, graveyardNumber - 1);\n                }\n            } else if (isOurGraveyardAccessible) {\n                if (graveyardNumber > game.getThisBoard().getGraveyard().size())\n                    throw new InvalidSelection();\n                else {\n                    this.selectedCard = game.getThisBoard().getGraveyard().get(graveyardNumber - 1);\n                    selectedCardAddress = new CardAddress(Place.Graveyard, Owner.Me, graveyardNumber - 1);\n                }\n            } else throw new InvalidSelection();\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if (input.containsKey(\"-d\")) {\n            if (selectedCard == null) {\n                throw new NoCardSelectedException();\n            }\n            deselect();\n        } else\n            throw new InvalidInput();\n\n        if (selectedCard == null)\n            throw new CardNotFoundException();\n    }\n\n    public void deselect() {\n        selectedCardAddress = null;\n        selectedCard = null;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/SpellTrapController.java b/src/main/java/controller/SpellTrapController.java
--- a/src/main/java/controller/SpellTrapController.java	
+++ b/src/main/java/controller/SpellTrapController.java	
@@ -33,7 +33,7 @@
     public static SpellTrapController getSpellTrapControllerBySpellTrap(SpellTrap spellTrap) {
         for (SpellTrapController spellTrapController : allSpellTrapControllers) {
             if (spellTrapController.getCard().getName().equals(spellTrap.getName())) {
-                    return spellTrapController;
+                return spellTrapController;
             }
         }
         return null;
@@ -120,7 +120,7 @@
     }
 
     public void select(String selectCommand) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {
-        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand.split("\\s+"));
+        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand);
         Game game = gameController.getGame();
         String addressNumber;
 
Index: src/main/java/controller/UserController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.*;\nimport model.User;\nimport view.Scan;\n\nimport java.util.HashMap;\nimport java.util.regex.Matcher;\n\npublic class UserController {\n    private static UserController userController;\n\n    private UserController() {\n    }\n\n    public static UserController getInstance() {\n        if (userController == null)\n            userController = new UserController();\n        return userController;\n    }\n\n    public String addNewUser(Matcher matcher) throws InvalidInput, DuplicateUsername, DuplicateNickname {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String username = null;\n        if (input.containsKey(\"username\"))\n            username = input.get(\"username\");\n        else if (input.containsKey(\"u\"))\n            username = input.get(\"u\");\n        if (username == null)\n            throw new InvalidInput();\n\n        String nickname = null;\n        if (input.containsKey(\"nickname\"))\n            nickname = input.get(\"nickname\");\n        else if (input.containsKey(\"n\"))\n            nickname = input.get(\"n\");\n        if (nickname == null)\n            throw new InvalidInput();\n\n        String password = null;\n        if (input.containsKey(\"password\"))\n            password = input.get(\"password\");\n        else if (input.containsKey(\"p\"))\n            password = input.get(\"p\");\n        if (password == null)\n            throw new InvalidInput();\n\n        if (User.checkUsernameExistence(username))\n            throw new DuplicateUsername();\n        if (User.checkNicknameExistence(nickname))\n            throw new DuplicateNickname();\n\n        new User(username, password, nickname);\n        return \"user created successfully!\";\n    }\n\n    public String removeUser(Matcher matcher) throws InvalidInput, WrongUsernamePassword {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String username = null;\n        if (input.containsKey(\"username\"))\n            username = input.get(\"username\");\n        else if (input.containsKey(\"u\"))\n            username = input.get(\"u\");\n        if (username == null)\n            throw new InvalidInput();\n\n        String password = null;\n        if (input.containsKey(\"password\"))\n            password = input.get(\"password\");\n        else if (input.containsKey(\"p\"))\n            password = input.get(\"p\");\n        if (password == null)\n            throw new InvalidInput();\n\n        User user = User.getUserByUsername(username);\n        if (user == null || !user.getPassword().equals(password))\n            throw new WrongUsernamePassword();\n\n        User.removeUser(user.getUsername());\n        return \"user removed successfully!\";\n    }\n\n    public String changePassword(Matcher matcher) throws InvalidInput, WrongPassword, SamePassword {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        if (!input.containsKey(\"password\") || !input.containsKey(\"p\"))\n            throw new InvalidInput();\n\n        String currentPassword = null;\n        if (input.containsKey(\"current\"))\n            currentPassword = input.get(\"current\");\n        else if (input.containsKey(\"c\"))\n            currentPassword = input.get(\"c\");\n        if (currentPassword == null)\n            throw new InvalidInput();\n\n        String newPassword = null;\n        if (input.containsKey(\"new\"))\n            newPassword = input.get(\"new\");\n        else if (input.containsKey(\"n\"))\n            newPassword = input.get(\"n\");\n        if (newPassword == null)\n            throw new InvalidInput();\n\n        if (!Database.getInstance().getCurrentUser().getPassword().equals(currentPassword))\n            throw new WrongPassword();\n\n        if (currentPassword.equals(newPassword))\n            throw new SamePassword();\n\n        Database.getInstance().getCurrentUser().setPassword(newPassword);\n        return \"password changed successfully!\";\n    }\n\n    public String changeNickname(Matcher matcher) throws InvalidInput, DuplicateNickname {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String nickname = null;\n        if (input.containsKey(\"nickname\"))\n            nickname = input.get(\"nickname\");\n        else if (input.containsKey(\"n\"))\n            nickname = input.get(\"n\");\n        if (nickname == null)\n            throw new InvalidInput();\n\n        if (User.checkNicknameExistence(nickname))\n            throw new DuplicateNickname();\n\n        Database.getInstance().getCurrentUser().setNickname(nickname);\n        return \"nickname changed successfully!\";\n    }\n\n    public String loginUser(Matcher matcher) throws InvalidInput, WrongUsernamePassword {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String username = null;\n        if (input.containsKey(\"username\"))\n            username = input.get(\"username\");\n        else if (input.containsKey(\"u\"))\n            username = input.get(\"u\");\n        if (username == null)\n            throw new InvalidInput();\n\n        String password = null;\n        if (input.containsKey(\"password\"))\n            password = input.get(\"password\");\n        else if (input.containsKey(\"p\"))\n            password = input.get(\"p\");\n        if (password == null)\n            throw new InvalidInput();\n\n        User user = User.getUserByUsername(username);\n        if (user == null || !user.getPassword().equals(password))\n            throw new WrongUsernamePassword();\n        Database.getInstance().setCurrentUser(user);\n        return \"user logged in successfully!\";\n    }\n\n    public String logout(Matcher matcher) {\n        Database.getInstance().setCurrentUser(null);\n        return \"user logged out successfully!\";\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/UserController.java b/src/main/java/controller/UserController.java
--- a/src/main/java/controller/UserController.java	
+++ b/src/main/java/controller/UserController.java	
@@ -20,8 +20,7 @@
     }
 
     public String addNewUser(Matcher matcher) throws InvalidInput, DuplicateUsername, DuplicateNickname {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String username = null;
         if (input.containsKey("username"))
@@ -57,8 +56,7 @@
     }
 
     public String removeUser(Matcher matcher) throws InvalidInput, WrongUsernamePassword {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String username = null;
         if (input.containsKey("username"))
@@ -85,8 +83,7 @@
     }
 
     public String changePassword(Matcher matcher) throws InvalidInput, WrongPassword, SamePassword {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         if (!input.containsKey("password") || !input.containsKey("p"))
             throw new InvalidInput();
@@ -118,8 +115,7 @@
     }
 
     public String changeNickname(Matcher matcher) throws InvalidInput, DuplicateNickname {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String nickname = null;
         if (input.containsKey("nickname"))
@@ -137,8 +133,7 @@
     }
 
     public String loginUser(Matcher matcher) throws InvalidInput, WrongUsernamePassword {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String username = null;
         if (input.containsKey("username"))
Index: src/main/java/controller/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.*;\nimport model.*;\nimport model.cards.Card;\nimport model.cards.SpellTrap;\nimport model.cards.monster.Monster;\nimport model.cards.spell.Spell;\nimport model.cards.spell.SpellType;\nimport model.cards.trap.Trap;\nimport view.Menu;\nimport view.Print;\nimport view.Scan;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\n\npublic class GameController {\n    private final int[] maxLifePoint = new int[]{0, 0};\n    private final int[] winningRounds = new int[]{0, 0};\n    private final User[] players = new User[2];\n    private final Stack<SpellTrapController> chain = new Stack<>();\n    private Game game;\n    private CardAddress selectedCardAddress = null;\n    private Card selectedCard = null;\n    private MonsterController selectedMonster = null;\n    private SpellTrapController selectedSpellTrap = null;\n    private final int roundNumber;\n    private boolean temporaryTurnChange = false;\n    private int currentRound = 0;\n\n    public GameController(User firstPlayer, User secondPayer, int round) throws NoPlayerAvailable {\n        players[0] = firstPlayer;\n        players[1] = secondPayer;\n        this.game = new Game(this, firstPlayer, secondPayer);\n        this.roundNumber = round;\n        game.nextPhase();\n    }\n\n    public GameController(User player, int round) throws NoPlayerAvailable {\n        players[0] = player;\n        players[1] = new Ai(this);\n        this.game = new Game(this, players[0], players[1]);\n        this.roundNumber = round;\n        game.nextPhase();\n    }\n\n    public boolean isTemporaryTurnChange() {\n        return temporaryTurnChange;\n    }\n\n    public void setTemporaryTurnChange(boolean temporaryTurnChange) {\n        this.temporaryTurnChange = temporaryTurnChange;\n    }\n\n    public Game getGame() {\n        return game;\n    }\n\n    public void setGame(Game game) {\n        this.game = game;\n    }\n\n    public String select(Matcher matcher) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {\n        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group(1).split(\"\\\\s+\"));\n\n        String addressNumber;\n        if ((addressNumber = Scan.getInstance().getValue(input, \"monster\", \"m\")) != null) {\n            int monsterNumber = Integer.parseInt(addressNumber);\n            if (monsterNumber > Board.CARD_NUMBER_IN_ROW)\n                throw new InvalidSelection();\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\")) {\n                if (game.getOtherBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedCard = game.getOtherBoard().getMonstersZone()[monsterNumber - 1].getCard();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Opponent, monsterNumber - 1);\n                }\n            } else {\n                if (game.getThisBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedMonster = game.getThisBoard().getMonstersZone()[monsterNumber - 1];\n                    selectedCard = selectedMonster.getCard();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Me, monsterNumber - 1);\n                }\n            }\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"spell\", \"s\")) != null) {\n            int spellNumber = Integer.parseInt(addressNumber);\n            if (spellNumber > Board.CARD_NUMBER_IN_ROW)\n                throw new InvalidSelection();\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\")) {\n                if (game.getOtherBoard().getSpellTrapZone()[spellNumber - 1] != null) {\n                    selectedCard = game.getOtherBoard().getSpellTrapZone()[spellNumber - 1].getCard();\n                    selectedCardAddress = new CardAddress(Place.SpellTrapZone, Owner.Opponent, spellNumber - 1);\n                }\n            } else {\n                if (game.getThisBoard().getSpellTrapZone()[spellNumber - 1] != null) {\n                    selectedSpellTrap = game.getThisBoard().getSpellTrapZone()[spellNumber - 1];\n                    selectedCard = selectedSpellTrap.getCard();\n                    selectedCardAddress = new CardAddress(Place.SpellTrapZone, Owner.Me, spellNumber - 1);\n                }\n            }\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if (Scan.getInstance().getValue(input, \"field\", \"f\") != null) {\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\")) {\n                if (game.getOtherBoard().getFieldZone() != null) {\n                    selectedSpellTrap = game.getOtherBoard().getFieldZone();\n                    selectedCard = selectedSpellTrap.getCard();\n                    selectedCardAddress = new CardAddress(Place.Field, Owner.Opponent);\n                }\n            } else {\n                if (game.getThisBoard().getFieldZone() != null) {\n                    selectedSpellTrap = game.getThisBoard().getFieldZone();\n                    selectedCard = selectedSpellTrap.getCard();\n                    selectedCardAddress = new CardAddress(Place.Field, Owner.Me);\n                }\n            }\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"hand\", \"h\")) != null) {\n            int handNumber = Integer.parseInt(addressNumber);\n            if (handNumber > game.getThisBoard().getHand().size())\n                throw new InvalidSelection();\n\n            selectedCard = game.getThisBoard().getHand().get(handNumber - 1);\n            selectedCardAddress = new CardAddress(Place.Hand, Owner.Me, handNumber - 1);\n        } else if (input.containsKey(\"-d\")) {\n            if (selectedCard == null) {\n                throw new NoCardSelectedException();\n            }\n            deselect();\n            return \"card deselected\";\n        } else\n            throw new InvalidInput();\n        return \"card selected\";\n    }\n\n    public void deselect() {\n        selectedCardAddress = null;\n        selectedCard = null;\n        selectedMonster = null;\n        selectedSpellTrap = null;\n    }\n\n    public void nextPhase() {\n        game.nextPhase();\n    }\n\n    public String summon(Matcher matcher) throws NoCardSelectedException, CannotSummonException, ActionNotAllowed,\n            MonsterNotFoundException, FullMonsterZone, AlreadySummonException, NotEnoughCardForTribute,\n            InvalidSelection {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.Hand ||\n                !(selectedCard instanceof Monster))\n            throw new CannotSummonException();\n\n        if (game.getPhase() != Phase.MAIN1 && game.getPhase() != Phase.MAIN2)\n            throw new ActionNotAllowed();\n\n        if (game.getThisBoard().getMonsterZoneNumber() >= Board.CARD_NUMBER_IN_ROW)\n            throw new FullMonsterZone();\n\n        if (game.isSummonOrSetThisTurn())\n            throw new AlreadySummonException();\n\n        Monster selectedMonster = (Monster) selectedCard;\n\n        if (selectedMonster.getLevel() > 4 && selectedMonster.getLevel() <= 6) {\n            if (game.getThisBoard().getMonsterZoneNumber() < 1)\n                throw new NotEnoughCardForTribute();\n\n            Integer monsterAddress = Scan.getInstance().getInteger();\n            if (monsterAddress == null)\n                return null;\n            if (game.getThisBoard().getMonstersZone()[monsterAddress - 1] == null)\n                throw new InvalidSelection();\n\n            game.getThisBoard().removeMonster(monsterAddress - 1);\n        } else if (selectedMonster.getLevel() > 6) {\n            if (game.getThisBoard().getMonsterZoneNumber() < 2)\n                throw new NotEnoughCardForTribute();\n\n            Integer monsterAddress1 = Scan.getInstance().getInteger();\n            Integer monsterAddress2 = Scan.getInstance().getInteger();\n            if (monsterAddress1 == null || monsterAddress2 == null)\n                return null;\n            if (game.getThisBoard().getMonstersZone()[monsterAddress1 - 1] == null ||\n                    game.getThisBoard().getMonstersZone()[monsterAddress2 - 1] == null)\n                throw new InvalidSelection();\n\n            game.getThisBoard().removeMonster(monsterAddress1 - 1);\n            game.getThisBoard().removeMonster(monsterAddress2 - 1);\n        }\n        MonsterController monster = game.getThisBoard().putMonster(selectedMonster, MonsterPosition.ATTACK);\n        game.setSummonOrSetThisTurn(true);\n        monster.summon();\n        deselect();\n        return \"summoned successfully\";\n    }\n\n    public String set(Matcher matcher) throws NoCardSelectedException, CannotSetException {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.Hand)\n            throw new CannotSetException();\n\n        if (game.getPhase() != Phase.MAIN1 && game.getPhase() != Phase.MAIN2)\n            throw new ActionNotAllowed();\n\n        if (selectedCard instanceof Monster) {\n            setMonster();\n        } else if (selectedCard instanceof Spell) {\n            setSpell();\n        } else if (selectedCard instanceof Trap) {\n            setTrap();\n        }\n        deselect();\n        return \"set successfully\";\n    }\n\n    private void setTrap() {\n        if (game.getThisBoard().getSpellTrapZoneNumber() >= Board.CARD_NUMBER_IN_ROW)\n            throw new FullSpellTrapZone();\n\n        Trap trap = (Trap) selectedCard;\n        game.getThisBoard().putSpellTrap(trap, SpellTrapPosition.DOWN);\n    }\n\n    private void setSpell() {\n        if (game.getThisBoard().getSpellTrapZoneNumber() >= Board.CARD_NUMBER_IN_ROW)\n            throw new FullSpellTrapZone();\n\n        Spell spell = (Spell) selectedCard;\n        game.getThisBoard().putSpellTrap(spell, SpellTrapPosition.DOWN);\n    }\n\n    private void setMonster() {\n        if (game.getThisBoard().getMonsterZoneNumber() >= Board.CARD_NUMBER_IN_ROW)\n            throw new FullMonsterZone();\n\n        if (game.isSummonOrSetThisTurn())\n            throw new AlreadySummonException();\n\n        Monster selectedMonster = (Monster) selectedCard;\n\n        if (selectedMonster.getLevel() > 4 && selectedMonster.getLevel() <= 6) {\n            if (game.getThisBoard().getMonsterZoneNumber() < 1)\n                throw new NotEnoughCardForTribute();\n\n            Integer monsterAddress = Scan.getInstance().getInteger();\n            if (monsterAddress == null)\n                return;\n            if (game.getThisBoard().getMonstersZone()[monsterAddress - 1] == null)\n                throw new InvalidSelection();\n\n            game.getThisBoard().removeMonster(monsterAddress - 1);\n        } else if (selectedMonster.getLevel() > 6) {\n            if (game.getThisBoard().getMonsterZoneNumber() < 2)\n                throw new NotEnoughCardForTribute();\n\n            Integer monsterAddress1 = Scan.getInstance().getInteger();\n            Integer monsterAddress2 = Scan.getInstance().getInteger();\n            if (monsterAddress1 == null || monsterAddress2 == null)\n                return;\n            if (game.getThisBoard().getMonstersZone()[monsterAddress1 - 1] == null ||\n                    game.getThisBoard().getMonstersZone()[monsterAddress2 - 1] == null)\n                throw new InvalidSelection();\n\n            game.getThisBoard().removeMonster(monsterAddress1 - 1);\n            game.getThisBoard().removeMonster(monsterAddress2 - 1);\n        }\n        MonsterController monster = game.getThisBoard().putMonster(selectedMonster, MonsterPosition.DEFENCE_DOWN);\n        game.setSummonOrSetThisTurn(true);\n        monster.set();\n    }\n\n    public String setPosition(Matcher matcher) {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.MonsterZone ||\n                !(selectedCard instanceof Monster))\n            throw new CannotChangeException();\n\n        if (game.getPhase() != Phase.MAIN1 && game.getPhase() != Phase.MAIN2)\n            throw new ActionNotAllowed();\n\n        MonsterPosition wantedPosition;\n        String position = matcher.group(1);\n        if (position.equals(\"attack\"))\n            wantedPosition = MonsterPosition.ATTACK;\n        else if (position.equals(\"defence\"))\n            wantedPosition = MonsterPosition.DEFENCE_UP;\n        else\n            throw new InvalidInput();\n\n        if (wantedPosition == MonsterPosition.ATTACK && selectedMonster.getPosition() != MonsterPosition.DEFENCE_UP)\n            throw new CannotChangeException();\n        if (wantedPosition == MonsterPosition.DEFENCE_UP && selectedMonster.getPosition() != MonsterPosition.ATTACK)\n            throw new CannotChangeException();\n\n        if (selectedMonster.isHasPositionChanged())\n            throw new AlreadyChangeException();\n\n        selectedMonster.setPosition(wantedPosition);\n        deselect();\n        return \"monster card position changed successfully\";\n    }\n\n    public String flipSummon(Matcher matcher) {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.MonsterZone ||\n                !(selectedCard instanceof Monster))\n            throw new CannotChangeException();\n\n        if (game.getPhase() != Phase.MAIN1 && game.getPhase() != Phase.MAIN2)\n            throw new ActionNotAllowed();\n\n        if (selectedMonster.getPosition() != MonsterPosition.DEFENCE_DOWN || selectedMonster.isMonsterNew())\n            throw new CannotFlipSummon();\n\n        selectedMonster.flip();\n        deselect();\n        return \"flip summoned successfully\";\n    }\n\n    public String attackDirect(Matcher matcher) {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.MonsterZone ||\n                !(selectedCard instanceof Monster))\n            throw new CannotAttackException();\n\n        if (game.getPhase() != Phase.BATTLE)\n            throw new ActionNotAllowed();\n\n        if (selectedMonster.isHasAttackedThisTurn())\n            throw new AlreadyAttackedException();\n\n        if (game.getOtherBoard().canDirectAttack())\n            throw new CannotAttackDirectlyException();\n\n        int damage = selectedMonster.getCard().getAttackPower();\n        game.decreaseOtherLifePoint(damage);\n        deselect();\n        return \"you opponent receives \" + damage + \" battle damage\";\n    }\n\n    public String attack(Matcher matcher) {\n        if (temporaryTurnChange)\n            throw new NotYourTurnException();\n        if (selectedCard != null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                selectedCardAddress.getPlace() != Place.MonsterZone ||\n                !(selectedCard instanceof Monster) ||\n                selectedMonster.getPosition() != MonsterPosition.ATTACK)\n            throw new CannotAttackException();\n\n        if (game.getPhase() != Phase.BATTLE)\n            throw new ActionNotAllowed();\n\n        if (selectedMonster.isHasAttackedThisTurn())\n            throw new AlreadyAttackedException();\n\n        int number = Integer.parseInt(matcher.group(1));\n        number--;\n        MonsterController toBeAttacked = game.getOtherBoard().getMonstersZone()[number];\n        if (toBeAttacked == null || toBeAttacked.canBeAttacked(selectedMonster))\n            throw new NoCardToAttackException();\n\n        String message = toBeAttacked.attack(selectedMonster);\n        deselect();\n        return message;\n    }\n\n\n    public String activateEffect(Matcher matcher) {\n        if (temporaryTurnChange) {\n            activateEffectOnOpponentTurn();\n            return null;\n        }\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                !(selectedCard instanceof Spell))\n            throw new CannotActivateException();\n\n        if (game.getPhase() != Phase.MAIN1 && game.getPhase() != Phase.MAIN2)\n            throw new ActionNotAllowed();\n\n        if (selectedCardAddress.getPlace() == Place.SpellTrapZone)\n            throw new AlreadyActivatedException();\n\n        Spell spell = (Spell) selectedCard;\n        if (game.getThisBoard().getSpellTrapZoneNumber() >= Board.CARD_NUMBER_IN_ROW &&\n                spell.getType() != SpellType.FIELD)\n            throw new FullSpellTrapZone();\n\n        if (!selectedSpellTrap.conditionMet())\n            throw new PreparationFailException();\n\n        if (spell.getType() == SpellType.FIELD) {\n            game.getThisBoard().putFiled(spell);\n        } else {\n            SpellController controller = (SpellController) game.getThisBoard().putSpellTrap(spell, SpellTrapPosition.UP);\n            chain.push(controller);\n            if (conditionsForChangingTurn()) {\n                changeTurn();\n            } else {\n                while (!chain.isEmpty()) {\n                    SpellTrapController current = chain.pop();\n                    current.activate();\n                }\n            }\n        }\n        deselect();\n        return \"spell activated\";\n    }\n\n    private void activateEffectOnOpponentTurn() {\n        if (selectedCard == null)\n            throw new NoCardSelectedException();\n\n        if (selectedCardAddress.getOwner() != Owner.Me ||\n                !(selectedCard instanceof SpellTrap))\n            throw new CannotActivateException();\n\n        SpellTrap spellTrap = (SpellTrap) selectedCard;\n        if (selectedCardAddress.getPlace() == Place.SpellTrapZone) {\n            chain.push(selectedSpellTrap);\n            while (!chain.isEmpty()) {\n                SpellTrapController current = chain.pop();\n                current.activate();\n            }\n        } else if (selectedCardAddress.getPlace() == Place.Hand) {\n            if (spellTrap instanceof Spell && ((Spell) spellTrap).getType() != SpellType.QUICK_PLAY) {\n                throw new ActionNotAllowed();\n            }\n            SpellTrapController controller = game.getThisBoard().putSpellTrap(spellTrap, SpellTrapPosition.UP);\n            chain.push(controller);\n            while (!chain.isEmpty()) {\n                SpellTrapController current = chain.pop();\n                current.activate();\n            }\n            controller.remove();\n        }\n        deselect();\n    }\n\n    public String showGraveyard(Matcher matcher) {\n        List<Card> graveyard = game.getThisBoard().getGraveyard();\n        if (graveyard.isEmpty()) {\n            Print.getInstance().printMessage(\"graveyard empty\");\n        } else {\n            int i = 1;\n            for (Card card : graveyard) {\n                Print.getInstance().printMessage(i + \". \" + card.getName() + \":\" + card.getDescription());\n                i++;\n            }\n        }\n        while (true) {\n            if (Scan.getInstance().getString().equals(\"back\"))\n                break;\n        }\n        return null;\n    }\n\n    public String showCard(Matcher matcher) {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        Map<String, String> input = Scan.getInstance().parseInput(rawInput);\n        if (input.containsKey(\"selected\") || input.containsKey(\"s\")) {\n            if (selectedCard == null)\n                throw new NoCardSelectedException();\n            if (selectedCardAddress.getOwner() == Owner.Opponent) {\n                if ((selectedCard instanceof Monster) && selectedMonster.getPosition() == MonsterPosition.DEFENCE_DOWN)\n                    throw new CardNotVisibleException();\n                if ((selectedCard instanceof SpellTrap) && selectedSpellTrap.getPosition() == SpellTrapPosition.DOWN)\n                    throw new CardNotVisibleException();\n            }\n            Print.getInstance().printCard(selectedCard);\n        } else {\n            String cardName = rawInput[2];\n            Card card = Card.getCard(cardName);\n            if (card == null)\n                throw new CardNotFoundException();\n            Print.getInstance().printCard(card);\n        }\n        return null;\n    }\n\n    public String surrender(Matcher matcher) {\n        game.setSurrenderPlayer(game.getTurn());\n        endGame();\n        return null;\n    }\n\n    public boolean isFinished() {\n        return false;\n    }\n\n    public void endGame() {\n        int winner = game.getWinner();\n        int[] scores = new int[2];\n        scores[winner] = 1000;\n        scores[1 - winner] = 0;\n        Print.getInstance().printMessage(game.getUser(winner).getUsername() + \" won the game\" +\n                \" and the score is: \" + scores[0] + \"-\" + scores[1]);\n        winningRounds[winner]++;\n        maxLifePoint[winner] = Math.max(maxLifePoint[winner], game.getLifePoint(winner));\n        if (winningRounds[0] > roundNumber / 2 || winningRounds[1] > roundNumber / 2) {\n            endMatch();\n        } else {\n            currentRound++;\n            try {\n                game = new Game(this, players[0], players[1]);\n            } catch (NoPlayerAvailable ignored) {\n\n            }\n        }\n    }\n\n    public void endMatch() {\n        int winner;\n        if (winningRounds[0] > roundNumber / 2)\n            winner = 0;\n        else\n            winner = 1;\n        int looser = 1 - winner;\n        int winnerScore = 1000 * roundNumber;\n        int looserScore = 0;\n\n        int winnerPrize = roundNumber * (1000 + maxLifePoint[winner]);\n        int looserPrize = roundNumber * 100;\n\n        players[winner].increaseScore(winnerScore);\n        players[looser].increaseScore(looserScore);\n        players[winner].increaseMoney(winnerPrize);\n        players[looser].increaseMoney(looserPrize);\n\n        int[] scores = new int[2];\n        scores[winner] = winnerScore;\n        scores[looser] = looserScore;\n        Print.getInstance().printMessage(players[winner].getUsername() + \" won the whole match\" +\n                \" with score: \" + scores[0] + \"-\" + scores[1]);\n\n        Menu.exitMenu(null);\n    }\n\n    public void showBoard() {\n\n    }\n\n    public boolean conditionsForChangingTurn() {\n        return false;\n    }\n\n    public void finishTemporaryChangeTurn() {\n        if (temporaryTurnChange)\n            game.temporaryChangeTurn();\n    }\n\n    public void changeTurn() {\n        if (!temporaryTurnChange && conditionsForChangingTurn()) {\n            game.temporaryChangeTurn();\n            Print.getInstance().printMessage(\"do you want to activate your trap and spell?\");\n            String answer = Scan.getInstance().getString();\n            if (!answer.equals(\"yse\")) {\n                game.temporaryChangeTurn();\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/GameController.java b/src/main/java/controller/GameController.java
--- a/src/main/java/controller/GameController.java	
+++ b/src/main/java/controller/GameController.java	
@@ -23,12 +23,12 @@
     private final int[] winningRounds = new int[]{0, 0};
     private final User[] players = new User[2];
     private final Stack<SpellTrapController> chain = new Stack<>();
+    private final int roundNumber;
     private Game game;
     private CardAddress selectedCardAddress = null;
     private Card selectedCard = null;
     private MonsterController selectedMonster = null;
     private SpellTrapController selectedSpellTrap = null;
-    private final int roundNumber;
     private boolean temporaryTurnChange = false;
     private int currentRound = 0;
 
@@ -65,7 +65,7 @@
     }
 
     public String select(Matcher matcher) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {
-        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group(1).split("\\s+"));
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String addressNumber;
         if ((addressNumber = Scan.getInstance().getValue(input, "monster", "m")) != null) {
@@ -501,7 +501,7 @@
 
     public String showCard(Matcher matcher) {
         String[] rawInput = matcher.group().split("\\s+");
-        Map<String, String> input = Scan.getInstance().parseInput(rawInput);
+        Map<String, String> input = Scan.getInstance().parseInput(matcher.group());
         if (input.containsKey("selected") || input.containsKey("s")) {
             if (selectedCard == null)
                 throw new NoCardSelectedException();
Index: src/main/java/controller/MainMenuController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.*;\nimport model.User;\nimport view.Scan;\nimport view.menus.*;\n\nimport java.util.HashMap;\nimport java.util.regex.Matcher;\n\npublic class MainMenuController {\n    public MainMenuController() {\n\n    }\n\n    public String creatNewGameWithAI(Matcher matcher) {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String roundString = Scan.getInstance().getValue(input, \"round\", \"r\");\n        if (roundString == null)\n            throw new InvalidInput();\n        int round;\n        try {\n            round = Integer.parseInt(roundString);\n        } catch (Exception e) {\n            throw new InvalidInput();\n        }\n        if (round != 1 && round != 3)\n            throw new NotSupportedRoundNumber();\n\n        GameController gameController = null;\n        try {\n            gameController = new GameController(Database.getInstance().getCurrentUser(), round);\n        } catch (NoPlayerAvailable ignored) {\n\n        }\n        new DuelMenu(gameController).execute();\n        return null;\n    }\n\n    public String createNewGameWithRealPlayer(Matcher matcher) {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n        String secondUsername = Scan.getInstance().getValue(input, \"second-player\", \"sp\");\n        if (secondUsername == null)\n            throw new InvalidInput();\n        String roundString = Scan.getInstance().getValue(input, \"rounds\", \"r\");\n        if (roundString == null)\n            throw new InvalidInput();\n        int round;\n        try {\n            round = Integer.parseInt(roundString);\n        } catch (Exception e) {\n            throw new InvalidInput();\n        }\n        User firstUser = Database.getInstance().getCurrentUser();\n        User secondUser = User.getUserByUsername(secondUsername);\n        if (secondUser == null)\n            throw new UsernameNotFoundException();\n        if (firstUser.getActiveDeck() == null)\n            throw new NoActiveDeck(firstUser.getUsername());\n        if (secondUser.getActiveDeck() == null)\n            throw new NoActiveDeck(secondUser.getUsername());\n\n        if (firstUser.getActiveDeck().isDeckValid())\n            throw new InvalidDeckException(firstUser.getUsername());\n        if (secondUser.getActiveDeck().isDeckValid())\n            throw new InvalidDeckException(secondUser.getUsername());\n\n        if (round != 1 && round != 3)\n            throw new NotSupportedRoundNumber();\n\n        try {\n            GameController gameController = new GameController(firstUser, secondUser, round);\n            new DuelMenu(gameController).execute();\n        } catch (NoPlayerAvailable ignored) {\n\n        }\n        return null;\n    }\n\n    public String enterMenu(Matcher matcher) {\n        String newMenu = matcher.group(1);\n        if (newMenu.contains(\"Login\"))\n            new LoginMenu().execute();\n        else if (newMenu.contains(\"Deck\"))\n            new DeckMenu().execute();\n        else if (newMenu.contains(\"Export\"))\n            new InterchangeMenu().execute();\n        else if (newMenu.contains(\"shop\"))\n            new ShopMenu().execute();\n        else if (newMenu.contains(\"Profile\"))\n            new ProfileMenu().execute();\n        else if (newMenu.contains(\"Score\"))\n            new ScoreBoardMenu().execute();\n        return null;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/MainMenuController.java b/src/main/java/controller/MainMenuController.java
--- a/src/main/java/controller/MainMenuController.java	
+++ b/src/main/java/controller/MainMenuController.java	
@@ -14,8 +14,7 @@
     }
 
     public String creatNewGameWithAI(Matcher matcher) {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String roundString = Scan.getInstance().getValue(input, "round", "r");
         if (roundString == null)
@@ -40,8 +39,7 @@
     }
 
     public String createNewGameWithRealPlayer(Matcher matcher) {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
         String secondUsername = Scan.getInstance().getValue(input, "second-player", "sp");
         if (secondUsername == null)
             throw new InvalidInput();
Index: src/test/java/view/ScanTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/view/ScanTest.java b/src/test/java/view/ScanTest.java
new file mode 100755
--- /dev/null	
+++ b/src/test/java/view/ScanTest.java	
@@ -0,0 +1,26 @@
+package view;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import java.util.HashMap;
+
+class ScanTest {
+    Scan scan = Scan.getInstance();
+
+    @Test
+    void parseInputWithNoDash() {
+        String input = "this input contains no dashes";
+        HashMap<String, String> result = scan.parseInput(input);
+        Assertions.assertEquals(0, result.size());
+    }
+
+    void parseNormalInput(){
+        String string = "this --input is --normal one";
+        HashMap<String,String> re
+    }
+
+    @Test
+    void getValue() {
+    }
+}
\ No newline at end of file
Index: src/main/java/controller/MonsterController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.*;\nimport model.*;\nimport model.cards.Card;\nimport model.cards.monster.Monster;\nimport view.Print;\nimport view.Scan;\n\nimport java.util.*;\n\npublic class MonsterController {\n    private static final HashMap<String, MonsterMakerInterface> MONSTER_MAKERS;\n    private static final ArrayList<MonsterController> allMonsterControllers;\n\n    static {\n        MONSTER_MAKERS = new HashMap<>();\n        allMonsterControllers = new ArrayList<>();\n\n        //Effective Monsters\n        MONSTER_MAKERS.put(\"Command knight\", MonsterController::makeCommandKnight);\n        MONSTER_MAKERS.put(\"Yomi Ship\", MonsterController::makeYomiShip);\n        MONSTER_MAKERS.put(\"Suijin\", MonsterController::makeSuijin);\n        MONSTER_MAKERS.put(\"Crab Turtle\", MonsterController::makeCrabTurtle);\n        MONSTER_MAKERS.put(\"Skull Gaurdian\", MonsterController::makeSkullGaurdian);\n        MONSTER_MAKERS.put(\"Man-Eater Bug\", MonsterController::makeManEaterBug);\n        MONSTER_MAKERS.put(\"Gate Guardian\", MonsterController::makeGateGuardian);\n        MONSTER_MAKERS.put(\"Scanner\", MonsterController::makeScanner);\n        MONSTER_MAKERS.put(\"Marshmallon\", MonsterController::makeMarshmallon);\n        MONSTER_MAKERS.put(\"Beast King Barbaros\", MonsterController::makeBeastKingBarbaros);\n        MONSTER_MAKERS.put(\"Texchanger\", MonsterController::makeTexchanger);\n        MONSTER_MAKERS.put(\"The Calculator\", MonsterController::makeTheCalculator);\n        MONSTER_MAKERS.put(\"Mirage Dragon\", MonsterController::makeMirageDragon);\n        MONSTER_MAKERS.put(\"Hearld of Creation\", MonsterController::makeHearldOfCreation);\n        MONSTER_MAKERS.put(\"Exploder Dragon\", MonsterController::makeExploderDragon);\n        MONSTER_MAKERS.put(\"Terratiger, the Empowered Warrior\\n\", MonsterController::makeTerratiger);\n        MONSTER_MAKERS.put(\"The Tricky\", MonsterController::makeTheTricky);\n    }\n\n    private final GameController gameController;\n    private Monster monster;\n    private MonsterPosition position;\n    private CardAddress monsterAddress;\n    private boolean hasPositionChanged;\n    private boolean isMonsterNew;\n    private boolean hasAttackedThisTurn;\n    private boolean hasActivateEffectThisTurn;\n    private boolean isHandAccessible;\n    private boolean isRivalMonsterZoneAccessible;\n    private boolean isOurMonsterZoneAccessible;\n    private boolean isRivalGraveyardAccessible;\n    private boolean isOurGraveyardAccessible;\n    private Card selectedCard;\n    private CardAddress selectedCardAddress;\n\n\n    private MonsterController(GameController gameController, Monster monster,\n                              MonsterPosition position, CardAddress monsterAddress) {\n        this.gameController = gameController;\n        this.monster = new Monster(monster);\n        setMonsterAddress(monsterAddress);\n        setPosition(position);\n        setMonsterNew(true);\n        setHasPositionChanged(false);\n        setHasAttackedThisTurn(false);\n        setHasActivateEffectThisTurn(false);\n        setHandAccessible(false);\n        setRivalGraveyardAccessible(false);\n        setRivalMonsterZoneAccessible(false);\n        setOurGraveyardAccessible(false);\n        setOurMonsterZoneAccessible(false);\n        setSelectedCard(null);\n        setSelectedCardAddress(null);\n        allMonsterControllers.add(this);\n    }\n\n    public static ArrayList<MonsterController> getAllMonsterControllers() {\n        return allMonsterControllers;\n    }\n\n    public static MonsterController getMonsterControllerByMonster(Monster monster) {\n        for (MonsterController monsterController : allMonsterControllers) {\n            if (monsterController.monster == monster) {\n                return monsterController;\n            }\n        }\n        return null;\n    }\n\n    public static MonsterController getInstance(GameController gameController, Monster monster,\n                                                MonsterPosition position, CardAddress monsterAddress)\n            throws MonsterNotFoundException {\n        for (String monsterName : MONSTER_MAKERS.keySet()) {\n            if (monster.getName().equals(monsterName)) {\n                return MONSTER_MAKERS.get(monsterName).make(gameController, monster, position, monsterAddress);\n            }\n        }\n        throw new MonsterNotFoundException();\n    }\n\n    private static MonsterController makeCommandKnight(GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            private final Set<MonsterController> underEffectMonsters = new HashSet<>();\n            private boolean isEffectActive = position.equals(MonsterPosition.ATTACK);\n\n            @Override\n            public void runMonsterEffect() {\n                if (isEffectActive) {\n                    //increase other monsters attackPower for 400\n                    MonsterController[] monstersZone = gameController.getGame().getThisBoard().getMonstersZone();\n                    for (MonsterController monsterController : monstersZone) {\n                        if (!underEffectMonsters.contains(monsterController)) {\n                            monsterController.monster.increaseAttackPower(400);\n                            underEffectMonsters.add(monsterController);\n                        }\n                    }\n                }\n            }\n\n            //cant be attacked while there are some other monsters in the field\n            @Override\n            public boolean canBeAttacked(MonsterController attacker) {\n                if (isEffectActive) {\n                    return gameController.getGame().getThisBoard().getMonstersZone().length < 2;\n                }\n                return true;\n            }\n\n            @Override\n            public void endMonsterEffect() {\n                for (MonsterController monsterController : underEffectMonsters) {\n                    monsterController.monster.decreaseAttackPower(400);\n                }\n                isEffectActive = false;\n            }\n        };\n    }\n\n    private static MonsterController makeYomiShip\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void remove(MonsterController attacker) {\n                gameController.getGame().getThisBoard().removeMonster(this);\n                gameController.getGame().getOtherBoard().removeMonster(attacker);\n            }\n        };\n    }\n\n    private static MonsterController makeSuijin\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            private final boolean wasEffectActiveBefore = false;\n            private boolean isEffectActive = false;\n\n            @Override\n            public void runMonsterEffect() {\n                if (!wasEffectActiveBefore) {\n                    isEffectActive = true;\n                }\n            }\n\n            @Override\n            public String attack(MonsterController attacker) {\n                if (isEffectActive) {\n                    int theAttackerPower = attacker.monster.getAttackPower();\n                    attacker.monster.setAttackPower(0);\n                    String toReturn = defaultAttack(attacker);\n                    attacker.monster.setAttackPower(theAttackerPower);\n                    isEffectActive = false;\n                    return toReturn;\n                }\n                return defaultAttack(attacker);\n            }\n\n        };\n    }\n\n    private static MonsterController makeCrabTurtle\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position,monsterAddress) {\n\n        };\n    }\n\n    private static MonsterController makeSkullGaurdian\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n\n        };\n    }\n\n    private static MonsterController makeManEaterBug\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void flip() {\n                setRivalMonsterZoneAccessible(true);\n                Print.getInstance().printMessage(\"Do you want to activate the card effect?\" +\n                        \"1. yes\" +\n                        \"2. no\");\n                Scanner scanner = Scan.getScanner();\n                String input = scanner.nextLine();\n\n                if (Integer.parseInt(input) == 1) {\n                    Print.getInstance().printMessage(\"Select one of rival Monsters to remove from his Monster Zone\");\n                    input = scanner.nextLine();\n                    select(input);\n                    MonsterController[] monstersZone = gameController.getGame().getOtherBoard().getMonstersZone();\n                    for (MonsterController monster : monstersZone) {\n                        if (monster.getMonster().getName().equals(getSelectedCard().getName())) {\n                            MonsterController selectedMonsterController = MonsterController.getMonsterControllerByMonster((Monster) getSelectedCard());\n                            gameController.getGame().getOtherBoard().removeMonster(selectedMonsterController);\n                        }\n                    }\n                }\n\n                this.setPosition(MonsterPosition.ATTACK);\n            }\n        };\n    }\n\n    private static MonsterController makeGateGuardian\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n        };\n    }\n\n    private static MonsterController makeScanner\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void runMonsterEffect() throws InvalidSelection {\n                if (!isHasActivateEffectThisTurn()) {\n                    Print.getInstance().printMessage(\"Do you want to activate the card effect?\" +\n                            \"1. yes\" +\n                            \"2. no\");\n                    Scanner scanner = Scan.getScanner();\n                    String input = scanner.nextLine();\n\n                    if (Integer.parseInt(input) == 1) {\n                        Print.getInstance().printMessage(\"Select a monster from rival GRAVEYARD\");\n                        input = scanner.nextLine();\n                        setRivalGraveyardAccessible(true);\n                        select(input);\n                        if (!(getSelectedCard() instanceof Monster)) {\n                            throw new InvalidSelection();\n                        } else {\n                            Monster selectedMonster = (Monster) getSelectedCard();\n                            setMonster(new Monster(selectedMonster));\n                        }\n                    }\n                }\n                setHasActivateEffectThisTurn(true);\n            }\n\n            @Override\n            public void endMonsterEffect() {\n                setMonster(Monster.getMonster(\"Scanner\"));\n            }\n        };\n    }\n\n    private static MonsterController makeMarshmallon\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void remove(MonsterController attacker) {\n                if (position.equals(MonsterPosition.DEFENCE_DOWN)) {\n                    gameController.getGame().decreaseOtherLifePoint(1000);\n                }\n            }\n        };\n    }\n\n    private static MonsterController makeBeastKingBarbaros\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n\n        };\n    }\n\n    private static MonsterController makeTexchanger\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n        };\n    }\n\n    private static MonsterController makeTheCalculator\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void runMonsterEffect() {\n                MonsterController[] monstersZone = gameController.getGame().getThisBoard().getMonstersZone();\n                for (MonsterController monsterController : monstersZone) {\n                    if (monsterController.position.equals(MonsterPosition.ATTACK)) {\n                        monster.increaseAttackPower(monsterController.monster.getLevel() * 300);\n                    }\n                }\n            }\n        };\n    }\n\n    private static MonsterController makeMirageDragon\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            final boolean isEffectActive = position.equals(MonsterPosition.ATTACK);\n\n            @Override\n            public void runMonsterEffect() {\n                if (isEffectActive) {\n                    //rival cannot active his spellTraps\n                }\n            }\n        };\n    }\n\n    private static MonsterController makeHearldOfCreation\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void runMonsterEffect() throws InvalidSelection {\n                if (!isHasActivateEffectThisTurn()) {\n                    Print.getInstance().printMessage(\"Do you want to activate the card effect?\" +\n                            \"1. yes\" +\n                            \"2. no\");\n                    Scanner scanner = Scan.getScanner();\n                    String input = scanner.nextLine();\n\n                    if (Integer.parseInt(input) == 1) {\n                        Print.getInstance().printMessage(\"Select a Card from your HAND to remove\");\n                        input = scanner.nextLine();\n                        setHandAccessible(true);\n                        select(input);\n                        gameController.getGame().getThisBoard().getHand().remove(getSelectedCard());\n\n                        setHandAccessible(false);\n                        setOurGraveyardAccessible(true);\n\n                        Print.getInstance().printMessage(\"Select a Monster from your GRAVEYARD with level 7 or more to put it in your HAND\");\n                        input = scanner.nextLine();\n                        select(input);\n                        if (!(getSelectedCard() instanceof Monster)) {\n                            throw new InvalidSelection();\n                        } else {\n                            Monster selectedMonster = (Monster) getSelectedCard();\n                            if (selectedMonster.getLevel() < 7)\n                                throw new InvalidSelection();\n                            else {\n                                gameController.getGame().getThisBoard().getGraveyard().remove(getSelectedCard());\n                                gameController.getGame().getThisBoard().addCardToHand(getSelectedCard());\n                            }\n                        }\n                        setOurGraveyardAccessible(false);\n                        setHasActivateEffectThisTurn(true);\n                    }\n                }\n            }\n        };\n    }\n\n    private static MonsterController makeExploderDragon\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void remove(MonsterController attacker) {\n                gameController.getGame().getThisBoard().removeMonster(this);\n                gameController.getGame().getOtherBoard().removeMonster(attacker);\n            }\n        };\n    }\n\n    private static MonsterController makeTerratiger\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n        };\n    }\n\n    private static MonsterController makeTheTricky\n            (GameController gameController, Monster monster,\n             MonsterPosition position, CardAddress monsterAddress){\n        return new MonsterController(gameController, monster, position, monsterAddress) {\n            @Override\n            public void summon() {\n                Print.getInstance().printMessage(\"Do you want to summon this card specially with remove a card from your HAND?\" +\n                        \"1. yes\" +\n                        \"2. no\");\n\n                Scanner scanner = Scan.getScanner();\n                String input = scanner.nextLine();\n\n                if (Integer.parseInt(input) == 1) {\n                    Print.getInstance().printMessage(\"Select a card from your HAND to remove\");\n\n                    input = scanner.nextLine();\n                    setHandAccessible(true);\n                    select(input);\n\n                    gameController.getGame().getThisBoard().getHand().remove(getSelectedCard());\n                }\n            }\n        };\n    }\n\n    public CardAddress getMonsterAddress() {\n        return monsterAddress;\n    }\n\n    public void setMonsterAddress(CardAddress monsterAddress) {\n        this.monsterAddress = monsterAddress;\n    }\n\n    public boolean isHasActivateEffectThisTurn() {\n        return hasActivateEffectThisTurn;\n    }\n\n    public void setHasActivateEffectThisTurn(boolean hasActivateEffectThisTurn) {\n        this.hasActivateEffectThisTurn = hasActivateEffectThisTurn;\n    }\n\n    public void setSelectedCardAddress(CardAddress selectedCardAddress) {\n        this.selectedCardAddress = selectedCardAddress;\n    }\n\n    public Card getSelectedCard() {\n        return selectedCard;\n    }\n\n    public void setSelectedCard(Card selectedCard) {\n        this.selectedCard = selectedCard;\n    }\n\n    public Monster getMonster() {\n        return monster;\n    }\n\n    public void setMonster(Monster monster) {\n        this.monster = monster;\n    }\n\n    public void setHandAccessible(boolean handAccessible) {\n        isHandAccessible = handAccessible;\n    }\n\n    public void setRivalMonsterZoneAccessible(boolean rivalMonsterZoneAccessible) {\n        isRivalMonsterZoneAccessible = rivalMonsterZoneAccessible;\n    }\n\n    public void setOurMonsterZoneAccessible(boolean ourMonsterZoneAccessible) {\n        isOurMonsterZoneAccessible = ourMonsterZoneAccessible;\n    }\n\n    public void setRivalGraveyardAccessible(boolean rivalGraveyardAccessible) {\n        isRivalGraveyardAccessible = rivalGraveyardAccessible;\n    }\n\n    public void setOurGraveyardAccessible(boolean ourGraveyardAccessible) {\n        isOurGraveyardAccessible = ourGraveyardAccessible;\n    }\n\n    public boolean isHasPositionChanged() {\n        return hasPositionChanged;\n    }\n\n    public void setHasPositionChanged(boolean hasPositionChanged) {\n        this.hasPositionChanged = hasPositionChanged;\n    }\n\n    public void finishTurn() {\n        hasPositionChanged = false;\n        isMonsterNew = false;\n    }\n\n    public void runMonsterEffect() {\n\n    }\n\n    public void endMonsterEffect() {\n\n    }\n\n    public boolean canBeAttacked(MonsterController attacker) {\n        return true;\n    }\n\n    public MonsterPosition getPosition() {\n        return position;\n    }\n\n    public void setPosition(MonsterPosition position) {\n        this.position = position;\n    }\n\n    public void summon() {\n\n    }\n\n    public void flip() {\n        this.setPosition(MonsterPosition.ATTACK);\n    }\n\n    public void remove(MonsterController attacker) {\n        gameController.getGame().getThisBoard().removeMonster(this);\n    }\n\n    public String getName() {\n        return monster.getName();\n    }\n\n    public Monster getCard() {\n        return this.monster;\n    }\n\n    public void set() {\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof MonsterController)) {\n            return false;\n        }\n\n        MonsterController monsterController = (MonsterController) o;\n\n        return monsterController.monster.getName().equals(this.monster.getName());\n    }\n\n    public boolean isMonsterNew() {\n        return isMonsterNew;\n    }\n\n    public void setMonsterNew(boolean monsterNew) {\n        this.isMonsterNew = monsterNew;\n    }\n\n    public boolean isHasAttackedThisTurn() {\n        return hasAttackedThisTurn;\n    }\n\n    public void setHasAttackedThisTurn(boolean hasAttackedThisTurn) {\n        this.hasAttackedThisTurn = hasAttackedThisTurn;\n    }\n\n    public String attack(MonsterController attacker) {\n        return defaultAttack(attacker);\n    }\n\n    public String defaultAttack(MonsterController attacker) {\n        int damage;\n        MonsterController defender = this;\n        Game game = gameController.getGame();\n        switch (defender.getPosition()) {\n            case ATTACK:\n                damage = attacker.getCard().getAttackPower() - defender.getCard().getAttackPower();\n                if (damage > 0) {\n                    defender.remove(attacker);\n                    game.decreaseOtherLifePoint(damage);\n                    return \"your opponent’s monster is destroyed and your opponent receives \" + damage + \"battle damage\";\n                } else if (damage == 0) {\n                    game.getThisBoard().removeMonster(attacker);\n                    defender.remove(attacker);\n                    return \"both you and your opponent monster cards are destroyed and no one receives damage\";\n                } else {\n                    damage = -damage;\n                    game.getThisBoard().removeMonster(attacker);\n                    game.decreaseThisLifePoint(damage);\n                    return \"your monster is destroyed and you receives \" + damage + \"battle damage\";\n                }\n            case DEFENCE_UP:\n                damage = attacker.getCard().getAttackPower() - defender.getCard().getDefencePower();\n                if (damage > 0) {\n                    defender.remove(attacker);\n                    return \"the defense position monster is destroyed\";\n                } else if (damage == 0) {\n                    return \"no card is destroyed\";\n                } else {\n                    damage = -damage;\n                    game.decreaseThisLifePoint(damage);\n                    return \"no card is destroyed and you received \" + damage + \" battle damage\";\n                }\n            case DEFENCE_DOWN:\n                String cardNameMessage = \"opponent’s monster card was <monster card >name and \";\n                damage = attacker.getCard().getAttackPower() - defender.getCard().getDefencePower();\n                if (damage > 0) {\n                    defender.remove(attacker);\n                    return cardNameMessage + \"the defense position monster is destroyed\";\n                } else if (damage == 0) {\n                    return cardNameMessage + \"no card is destroyed\";\n                } else {\n                    damage = -damage;\n                    game.decreaseThisLifePoint(damage);\n                    return cardNameMessage + \"no card is destroyed and you received \" + damage + \" battle damage\";\n                }\n        }\n        return null;\n    }\n\n    public void select(String selectCommand) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {\n        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand.split(\"\\\\s+\"));\n        Game game = gameController.getGame();\n        String addressNumber;\n\n\n        if ((addressNumber = Scan.getInstance().getValue(input, \"monster\", \"m\")) != null) {\n            int monsterNumber = Integer.parseInt(addressNumber);\n            if (monsterNumber > Board.CARD_NUMBER_IN_ROW)\n                throw new InvalidSelection();\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\") && isRivalMonsterZoneAccessible) {\n                if (game.getOtherBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedCard = game.getOtherBoard().getMonstersZone()[monsterNumber - 1].getMonster();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Opponent, monsterNumber - 1);\n                }\n            } else if (isOurMonsterZoneAccessible) {\n                if (game.getThisBoard().getMonstersZone()[monsterNumber - 1] != null) {\n                    selectedCard = game.getThisBoard().getMonstersZone()[monsterNumber - 1].getMonster();\n                    selectedCardAddress = new CardAddress(Place.MonsterZone, Owner.Me, monsterNumber - 1);\n                }\n            } else throw new InvalidSelection();\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"hand\", \"h\")) != null && isHandAccessible) {\n            int handNumber = Integer.parseInt(addressNumber);\n            if (handNumber > game.getThisBoard().getHand().size())\n                throw new InvalidSelection();\n\n            selectedCard = game.getThisBoard().getHand().get(handNumber - 1);\n            selectedCardAddress = new CardAddress(Place.Hand, Owner.Me, handNumber - 1);\n\n            if (this.selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if ((addressNumber = Scan.getInstance().getValue(input, \"graveyard\", \"g\")) != null) {\n            int graveyardNumber = Integer.parseInt(addressNumber);\n\n            if (input.containsKey(\"opponent\") || input.containsKey(\"o\") && isRivalGraveyardAccessible) {\n                if (graveyardNumber > game.getOtherBoard().getGraveyard().size())\n                    throw new InvalidSelection();\n                else {\n                    this.selectedCard = game.getOtherBoard().getGraveyard().get(graveyardNumber - 1);\n                    selectedCardAddress = new CardAddress(Place.Graveyard, Owner.Opponent, graveyardNumber - 1);\n                }\n            } else if (isOurGraveyardAccessible) {\n                if (graveyardNumber > game.getThisBoard().getGraveyard().size())\n                    throw new InvalidSelection();\n                else {\n                    this.selectedCard = game.getThisBoard().getGraveyard().get(graveyardNumber - 1);\n                    selectedCardAddress = new CardAddress(Place.Graveyard, Owner.Me, graveyardNumber - 1);\n                }\n            } else throw new InvalidSelection();\n\n            if (selectedCard == null)\n                throw new CardNotFoundException();\n\n        } else if (input.containsKey(\"-d\")) {\n            if (selectedCard == null) {\n                throw new NoCardSelectedException();\n            }\n            deselect();\n        } else\n            throw new InvalidInput();\n\n        if (selectedCard == null)\n            throw new CardNotFoundException();\n    }\n\n    public void deselect() {\n        selectedCardAddress = null;\n        selectedCard = null;\n    }\n\n    public interface MonsterMakerInterface {\n        MonsterController make(GameController gameController, Monster monster,\n                               MonsterPosition position, CardAddress monsterAddress);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/MonsterController.java b/src/main/java/controller/MonsterController.java
--- a/src/main/java/controller/MonsterController.java	
+++ b/src/main/java/controller/MonsterController.java	
@@ -99,7 +99,7 @@
     }
 
     private static MonsterController makeCommandKnight(GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+                                                       MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             private final Set<MonsterController> underEffectMonsters = new HashSet<>();
             private boolean isEffectActive = position.equals(MonsterPosition.ATTACK);
@@ -139,7 +139,7 @@
 
     private static MonsterController makeYomiShip
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void remove(MonsterController attacker) {
@@ -151,7 +151,7 @@
 
     private static MonsterController makeSuijin
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             private final boolean wasEffectActiveBefore = false;
             private boolean isEffectActive = false;
@@ -181,15 +181,15 @@
 
     private static MonsterController makeCrabTurtle
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
-        return new MonsterController(gameController, monster, position,monsterAddress) {
+             MonsterPosition position, CardAddress monsterAddress) {
+        return new MonsterController(gameController, monster, position, monsterAddress) {
 
         };
     }
 
     private static MonsterController makeSkullGaurdian
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
 
         };
@@ -197,7 +197,7 @@
 
     private static MonsterController makeManEaterBug
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void flip() {
@@ -228,14 +228,14 @@
 
     private static MonsterController makeGateGuardian
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
         };
     }
 
     private static MonsterController makeScanner
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void runMonsterEffect() throws InvalidSelection {
@@ -271,7 +271,7 @@
 
     private static MonsterController makeMarshmallon
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void remove(MonsterController attacker) {
@@ -284,7 +284,7 @@
 
     private static MonsterController makeBeastKingBarbaros
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
 
         };
@@ -292,14 +292,14 @@
 
     private static MonsterController makeTexchanger
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
         };
     }
 
     private static MonsterController makeTheCalculator
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void runMonsterEffect() {
@@ -315,7 +315,7 @@
 
     private static MonsterController makeMirageDragon
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             final boolean isEffectActive = position.equals(MonsterPosition.ATTACK);
 
@@ -330,7 +330,7 @@
 
     private static MonsterController makeHearldOfCreation
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void runMonsterEffect() throws InvalidSelection {
@@ -375,7 +375,7 @@
 
     private static MonsterController makeExploderDragon
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void remove(MonsterController attacker) {
@@ -387,14 +387,14 @@
 
     private static MonsterController makeTerratiger
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
         };
     }
 
     private static MonsterController makeTheTricky
             (GameController gameController, Monster monster,
-             MonsterPosition position, CardAddress monsterAddress){
+             MonsterPosition position, CardAddress monsterAddress) {
         return new MonsterController(gameController, monster, position, monsterAddress) {
             @Override
             public void summon() {
@@ -616,7 +616,7 @@
     }
 
     public void select(String selectCommand) throws InvalidSelection, CardNotFoundException, InvalidInput, NoCardSelectedException {
-        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand.split("\\s+"));
+        HashMap<String, String> input = Scan.getInstance().parseInput(selectCommand);
         Game game = gameController.getGame();
         String addressNumber;
 
Index: src/main/java/controller/DeckController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport exceptions.*;\nimport model.Deck;\nimport model.User;\nimport model.cards.Card;\nimport view.Scan;\n\nimport java.util.HashMap;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\n\npublic class DeckController {\n    private static DeckController deckController;\n\n    private DeckController() {\n    }\n\n    public static DeckController getInstance() {\n        if (deckController == null)\n            deckController = new DeckController();\n        return deckController;\n    }\n\n    public String createDeck(Matcher matcher) throws RepeatedDeckNameException {\n        String deckName = matcher.group(1);\n        if (!Deck.checkDeckNameExistence(deckName)) {\n            new Deck(deckName, Database.getInstance().getCurrentUser().getUsername());\n            Database.getInstance().getCurrentUser().addDeckToUserDecks(Deck.getDeckByDeckName(deckName));\n            return \"deck created successfully!\";\n        }\n        else throw new RepeatedDeckNameException(deckName);\n    }\n\n    public String removeDeck(Matcher matcher) throws DeckNameDoesntExistException {\n        String deckName = matcher.group(1);\n        if (Deck.checkDeckNameExistence(deckName)) {\n            Objects.requireNonNull(User.getUserByUsername(Database.getInstance().getCurrentUser().getUsername())).getAllDecks().remove(deckName);\n            Deck.getAllDecks().removeIf(deck -> deck.getName().equals(deckName));\n            return \"deck deleted successfully!\";\n        } else throw new DeckNameDoesntExistException(deckName);\n    }\n\n    public String setActive(Matcher matcher) throws DeckNameDoesntExistException {\n        String deckName = matcher.group(1);\n        if (Deck.checkDeckNameExistence(deckName)) {\n            Database.getInstance().getCurrentUser().setActiveDeck(Deck.getDeckByDeckName(deckName));\n            return \"deck activated successfully!\";\n        }\n        else throw new DeckNameDoesntExistException(deckName);\n    }\n\n    public String addCard(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException, CardNotFoundException,\n            InvalidNumberOfACardException, FullMainDeckException, FullSideDeckException {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String cardName = null;\n        if (input.containsKey(\"card\"))\n            cardName = input.get(\"card\");\n        else if (input.containsKey(\"c\"))\n            cardName = input.get(\"c\");\n        if (cardName == null)\n            throw new InvalidInput();\n\n        String deckName = null;\n        if (input.containsKey(\"deck\"))\n            deckName = input.get(\"deck\");\n        else if (input.containsKey(\"d\"))\n            deckName = input.get(\"d\");\n        if (deckName == null)\n            throw new InvalidInput();\n\n        if (!Database.getInstance().getCurrentUser().doesUserHaveThisCard(cardName))\n            throw new CardNotFoundException();\n        if (!Deck.checkDeckNameExistence(deckName))\n            throw new DeckNameDoesntExistException(deckName);\n\n        if (input.containsKey(\"side\")) {\n            if (Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).getSideDeck().size() == 15)\n                throw new FullSideDeckException();\n        } else {\n            if (Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).getMainDeck().size() == 60)\n                throw new FullMainDeckException();\n        }\n\n        if (!Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).IsNumberOfTheCardInDeckValid(cardName))\n            throw new InvalidNumberOfACardException(cardName, deckName);\n\n        if (input.containsKey(\"side\"))\n            Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).addCardToSideDeck(Card.getCard(cardName));\n        else\n            Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).addCardToMainDeck(Card.getCard(cardName));\n        return \"card added to deck successfully!\";\n    }\n\n    public String removeCard(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException,\n            CardNotFoundInSideDeck, CardNotFoundInMainDeck {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String cardName = null;\n        if (input.containsKey(\"card\"))\n            cardName = input.get(\"card\");\n        else if (input.containsKey(\"c\"))\n            cardName = input.get(\"c\");\n        if (cardName == null)\n            throw new InvalidInput();\n\n        String deckName = null;\n        if (input.containsKey(\"deck\"))\n            deckName = input.get(\"deck\");\n        else if (input.containsKey(\"d\"))\n            deckName = input.get(\"d\");\n        if (deckName == null)\n            throw new InvalidInput();\n\n        if (!Deck.checkDeckNameExistence(deckName))\n            throw new DeckNameDoesntExistException(deckName);\n\n        if (input.containsKey(\"side\")) {\n            if (!Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).doesCardExistInSideDeck(cardName))\n                throw new CardNotFoundInSideDeck(cardName);\n        } else {\n            if (!Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).doesCardExistInMainDeck(cardName))\n                throw new CardNotFoundInMainDeck(cardName);\n        }\n\n\n        if (input.containsKey(\"side\"))\n            Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).deleteCardFromSideDeck(Card.getCard(cardName));\n        else\n            Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).deleteCardFromMainDeck(Card.getCard(cardName));\n\n        return \"card removed form deck successfully\";\n    }\n\n    public String showDeck(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException {\n        String[] rawInput = matcher.group().split(\"\\\\s+\");\n        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);\n\n        String deckName = null;\n        if (input.containsKey(\"deck-name\"))\n            deckName = input.get(\"deck-name\");\n        else if (input.containsKey(\"d-n\"))\n            deckName = input.get(\"d-n\");\n        if (deckName == null)\n            throw new InvalidInput();\n\n        if (!Deck.checkDeckNameExistence(deckName))\n            throw new DeckNameDoesntExistException(deckName);\n\n        if (input.containsKey(\"side\"))\n            return Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).showDeck(\"side\");\n        else\n            return Objects.requireNonNull(Deck.getDeckByDeckName(deckName)).showDeck(\"main\");\n    }\n\n    public String showCards(Matcher matcher) {\n        return Database.getInstance().getCurrentUser().showAllCards();\n    }\n\n\n    public String showAllDeck(Matcher matcher) {\n        return Database.getInstance().getCurrentUser().showAllDecks();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controller/DeckController.java b/src/main/java/controller/DeckController.java
--- a/src/main/java/controller/DeckController.java	
+++ b/src/main/java/controller/DeckController.java	
@@ -28,8 +28,7 @@
             new Deck(deckName, Database.getInstance().getCurrentUser().getUsername());
             Database.getInstance().getCurrentUser().addDeckToUserDecks(Deck.getDeckByDeckName(deckName));
             return "deck created successfully!";
-        }
-        else throw new RepeatedDeckNameException(deckName);
+        } else throw new RepeatedDeckNameException(deckName);
     }
 
     public String removeDeck(Matcher matcher) throws DeckNameDoesntExistException {
@@ -46,14 +45,12 @@
         if (Deck.checkDeckNameExistence(deckName)) {
             Database.getInstance().getCurrentUser().setActiveDeck(Deck.getDeckByDeckName(deckName));
             return "deck activated successfully!";
-        }
-        else throw new DeckNameDoesntExistException(deckName);
+        } else throw new DeckNameDoesntExistException(deckName);
     }
 
     public String addCard(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException, CardNotFoundException,
             InvalidNumberOfACardException, FullMainDeckException, FullSideDeckException {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String cardName = null;
         if (input.containsKey("card"))
@@ -96,8 +93,7 @@
 
     public String removeCard(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException,
             CardNotFoundInSideDeck, CardNotFoundInMainDeck {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String cardName = null;
         if (input.containsKey("card"))
@@ -136,8 +132,7 @@
     }
 
     public String showDeck(Matcher matcher) throws InvalidInput, DeckNameDoesntExistException {
-        String[] rawInput = matcher.group().split("\\s+");
-        HashMap<String, String> input = Scan.getInstance().parseInput(rawInput);
+        HashMap<String, String> input = Scan.getInstance().parseInput(matcher.group());
 
         String deckName = null;
         if (input.containsKey("deck-name"))
